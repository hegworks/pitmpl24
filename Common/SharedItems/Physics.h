#pragma once

#include "btBulletDynamicsCommon.h"
#include "RoomChangeType.h"
#include <functional>
#include <glm/glm.hpp>
#include <stdexcept>

namespace Uknitty
{

class Physics
{
public:
	Physics();
	~Physics();

	enum class PhysicsType
	{
		SOLID,
		PLAYER,
		ROOM_CHANGE,
		ENEMY,
	};

	struct UserPointerData
	{
		PhysicsType physicsType;
		RoomChangeType roomChangeType;
		std::string name;
		void* extraData;  // Optional additional data
	};

	void InitialzeWithBoxShape(glm::vec3 position, glm::vec3 scale, float mass);
	void InitialzeWithCapsuleShape(glm::vec3 position, float radius, float height, float mass);

	// best to allow our Object to set and return use things in accessors
	//void SetShape(btCollisionShape* collisionShape) { m_collisionShape = collisionShape; }
	//void SetRighidBody(btRigidBody* rigidBody) { m_rigidBody = rigidBody; }

	btCollisionShape* GetShape() { return m_collisionShape; }
	btRigidBody* GetRigidBody() { return m_rigidBody; }
	btMotionState* GetMotionState() { return m_motionState; }

	std::function<void(const btCollisionObject* other)> m_collisionCallback;

	//// couple of useful utility functions to simplify the rotate and position of our physics objects 
	//// these act on the Rigid body and therefore will reposition/orient an object while it is
	//// in the physics world, useful for restarting or teleporting.
	void SetOrientation(btQuaternion rotation)
	{
		// could just m_body->setXXX but there's a slim chance you might add multiple rigid bodies to an object
		// and you would make GetRigidBody return the active one, so this is a safer method to allow for later expansion
		m_rigidBody->setWorldTransform(btTransform(rotation, m_rigidBody->getWorldTransform().getOrigin()));
	}

	void SetPosition(btVector3 position)
	{
		m_rigidBody->setWorldTransform(btTransform(m_rigidBody->getOrientation(), position));
	}

	void SetPosition(glm::vec3 position)
	{
		SetPosition(GLMVec3ToBtVec3(position));
	}

	// This gets the Motionstate transform, which is useful variables made available after the step
	// as these are generated by the step system, they should be used as read only, as writing to them
	// has no effect and sending them back to the motionstate is not useful,
	void GetTransform()
	{
		if(m_motionState)
			return m_motionState->getWorldTransform(m_rigidBody->getWorldTransform()); //this is the important part
	}

	static inline glm::vec3 BtVec3ToGLMVec3(btVector3 vector)
	{
		return glm::vec3(vector.getX(), vector.getY(), vector.getZ());
	}

	static inline btVector3 GLMVec3ToBtVec3(glm::vec3 vector)
	{
		return btVector3(vector.x, vector.y, vector.z);
	}

	enum class Color
	{
		RED,
		GREEN,
		BLUE,
		YELLOW,
		PINK,
		CYAN,
		BLACK,
		WHITE,
	};

	static inline btVector3 GetBtColor(Color color)
	{
		switch(color)
		{
			case Color::RED:
				return btVector3(1, 0, 0);
			case Color::GREEN:
				return btVector3(0, 1, 0);
			case Color::BLUE:
				return btVector3(0, 0, 1);
			case Color::YELLOW:
				return btVector3(1, 1, 0);
			case Color::PINK:
				return btVector3(1, 0, 1);
			case Color::CYAN:
				return btVector3(0, 1, 1);
			case Color::BLACK:
				return btVector3(0, 0, 0);
			case Color::WHITE:
				return btVector3(1, 1, 1);
			default:
				throw std::runtime_error("Color not found");
		}
	}

	void SetUserPointerData(UserPointerData* userPointerData)
	{
		m_userPointerData = userPointerData;
		m_rigidBody->setUserPointer(m_userPointerData);
	}

	UserPointerData* GetUserPointerData() const { return m_userPointerData; }

	void SetCollisionCallback(std::function<void(const btCollisionObject* other)> callback)
	{
		m_collisionCallback = callback;
	}

	void OnCollision(const btCollisionObject* other)
	{
		if(m_collisionCallback)
		{
			m_collisionCallback(other);
		}
	}

private:
	btRigidBody* m_rigidBody = nullptr;
	btCollisionShape* m_collisionShape = nullptr;
	btMotionState* m_motionState = nullptr; // the general position, orientation and scale of our object to return back
	UserPointerData* m_userPointerData = nullptr;

	void Initialze(btCollisionShape* btCollisionShape, glm::vec3 position, glm::vec3 scale, float mass);
};

} // namespace Uknitty
